// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPlayer = `-- name: AddPlayer :one
INSERT INTO user_hands (
	game_id, user_id
) VALUES (
	$1, $2
)
RETURNING game_id, user_id, nobles, coins, owned_cards, reserved_cards
`

type AddPlayerParams struct {
	GameID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) AddPlayer(ctx context.Context, arg AddPlayerParams) (UserHand, error) {
	row := q.db.QueryRow(ctx, addPlayer, arg.GameID, arg.UserID)
	var i UserHand
	err := row.Scan(
		&i.GameID,
		&i.UserID,
		&i.Nobles,
		&i.Coins,
		&i.OwnedCards,
		&i.ReservedCards,
	)
	return i, err
}

const createGame = `-- name: CreateGame :one
INSERT INTO games (
	hash_id, table_id, game
) VALUES (
	$1, $2, $3
)
RETURNING game_id, hash_id, table_id, game
`

type CreateGameParams struct {
	HashID  string
	TableID pgtype.UUID
	Game    GameData
}

func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame, arg.HashID, arg.TableID, arg.Game)
	var i Game
	err := row.Scan(
		&i.GameID,
		&i.HashID,
		&i.TableID,
		&i.Game,
	)
	return i, err
}

const createTable = `-- name: CreateTable :one
INSERT INTO tables (
	display_name
) VALUES (
	$1
)
RETURNING table_id, display_name, created_at, updated_at
`

func (q *Queries) CreateTable(ctx context.Context, displayName string) (Table, error) {
	row := q.db.QueryRow(ctx, createTable, displayName)
	var i Table
	err := row.Scan(
		&i.TableID,
		&i.DisplayName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
	name
) VALUES (
	$1
)
RETURNING user_id, name, created_at, updated_at
`

func (q *Queries) CreateUser(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRow(ctx, createUser, name)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGame = `-- name: GetGame :one
SELECT game_id, hash_id, table_id, game FROM games
WHERE table_id = $1 LIMIT 1
`

func (q *Queries) GetGame(ctx context.Context, tableID pgtype.UUID) (Game, error) {
	row := q.db.QueryRow(ctx, getGame, tableID)
	var i Game
	err := row.Scan(
		&i.GameID,
		&i.HashID,
		&i.TableID,
		&i.Game,
	)
	return i, err
}

const getParticipants = `-- name: GetParticipants :many
SELECT
	u.user_id,
	u.name
FROM users AS u
JOIN user_tables AS ut ON u.user_id = ut.user_id
JOIN tables AS t ON ut.table_id = t.table_id
WHERE t.table_id = $1
`

type GetParticipantsRow struct {
	UserID pgtype.UUID
	Name   string
}

func (q *Queries) GetParticipants(ctx context.Context, tableID pgtype.UUID) ([]GetParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getParticipants, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipantsRow
	for rows.Next() {
		var i GetParticipantsRow
		if err := rows.Scan(&i.UserID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlayers = `-- name: GetPlayers :many
SELECT
	u.user_id,
	u.name
FROM games AS g
JOIN user_hands AS uh ON g.game_id = uh.game_id
JOIN users AS u ON uh.user_id = u.user_id
WHERE g.table_id = $1
`

type GetPlayersRow struct {
	UserID pgtype.UUID
	Name   string
}

func (q *Queries) GetPlayers(ctx context.Context, tableID pgtype.UUID) ([]GetPlayersRow, error) {
	rows, err := q.db.Query(ctx, getPlayers, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlayersRow
	for rows.Next() {
		var i GetPlayersRow
		if err := rows.Scan(&i.UserID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id, name, created_at, updated_at FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, userID pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTables = `-- name: ListTables :many
SELECT table_id, display_name, created_at, updated_at FROM tables
`

func (q *Queries) ListTables(ctx context.Context) ([]Table, error) {
	rows, err := q.db.Query(ctx, listTables)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Table
	for rows.Next() {
		var i Table
		if err := rows.Scan(
			&i.TableID,
			&i.DisplayName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGame = `-- name: UpdateGame :exec
UPDATE games
SET game = $2
WHERE game_id = $1
`

type UpdateGameParams struct {
	GameID pgtype.UUID
	Game   GameData
}

func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) error {
	_, err := q.db.Exec(ctx, updateGame, arg.GameID, arg.Game)
	return err
}

const updateUserCoins = `-- name: UpdateUserCoins :exec
UPDATE user_hands
SET coins = $3
WHERE user_id = $1 AND game_id = $2
`

type UpdateUserCoinsParams struct {
	UserID pgtype.UUID
	GameID pgtype.UUID
	Coins  []Gemtype
}

func (q *Queries) UpdateUserCoins(ctx context.Context, arg UpdateUserCoinsParams) error {
	_, err := q.db.Exec(ctx, updateUserCoins, arg.UserID, arg.GameID, arg.Coins)
	return err
}

const updateUserNoble = `-- name: UpdateUserNoble :exec
UPDATE user_hands
SET nobles = $3
WHERE user_id = $1 AND game_id = $2
`

type UpdateUserNobleParams struct {
	UserID pgtype.UUID
	GameID pgtype.UUID
	Nobles []Noble
}

func (q *Queries) UpdateUserNoble(ctx context.Context, arg UpdateUserNobleParams) error {
	_, err := q.db.Exec(ctx, updateUserNoble, arg.UserID, arg.GameID, arg.Nobles)
	return err
}

const updateUserOwnedCards = `-- name: UpdateUserOwnedCards :exec
UPDATE user_hands
SET owned_cards = $3
WHERE user_id = $1 AND game_id = $2
`

type UpdateUserOwnedCardsParams struct {
	UserID     pgtype.UUID
	GameID     pgtype.UUID
	OwnedCards []Card
}

func (q *Queries) UpdateUserOwnedCards(ctx context.Context, arg UpdateUserOwnedCardsParams) error {
	_, err := q.db.Exec(ctx, updateUserOwnedCards, arg.UserID, arg.GameID, arg.OwnedCards)
	return err
}

const updateUserReserved = `-- name: UpdateUserReserved :exec
UPDATE user_hands
SET reserved_cards = $3
WHERE user_id = $1 AND game_id = $2
`

type UpdateUserReservedParams struct {
	UserID        pgtype.UUID
	GameID        pgtype.UUID
	ReservedCards []Card
}

func (q *Queries) UpdateUserReserved(ctx context.Context, arg UpdateUserReservedParams) error {
	_, err := q.db.Exec(ctx, updateUserReserved, arg.UserID, arg.GameID, arg.ReservedCards)
	return err
}
